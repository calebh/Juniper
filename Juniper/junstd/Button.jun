module Button
open(Io)

/*
    Interface: Button
*/

/*
    Type: alias buttonState

    The buttonState type is used by the debounce functions to store state.

    | alias buttonState = { actualState : pinState, lastState : pinState, lastDebounceTime : uint32 }

    Members:
        actualState : Io:pinState - The actual state of the button
        lastState : Io:pinState - The last state of the button (on the previous
            update)
        lastDebounceTime : uint32 - The last debounce time
*/
alias buttonState = { actualState : pinState, lastState : pinState, lastDebounceTime : uint32 }

/*
    Variable: state

    Useful for initializing a <buttonState>, initializing the actualState to Io:low(),
    lastState to Io:low() && lastDebounceTime to 0

    Type:
    | buttonState
*/
let state : buttonState = { actualState := Io:low(), lastState := Io:low(), lastDebounceTime := 0 }

/*
    Function: debounceDelay

    Debounces the incoming Io:pinState signal by checking twice in a short
    period of time to make sure the pushbutton is definitely pressed.

    Type Signature:
    
        | (uint16, inout buttonState, sig<pinState>) -> sig<pinState>

    Parameters
        delay : uint16 - The amount of time to wait in milliseconds before
            checking the pushbutton again
        buttonState : inout buttonState - Used to keep track of state between
            debounce calls
        incoming : sig<pinState> - The incoming signal

    Returns:
        A signal that will ideally reflect the actual state of the button.

    See Also:
        Io:risingEdge, Io:fallingEdge, Io:edge
*/
fun debounceDelay(delay : uint16, inout buttonState : buttonState, incoming : sig<pinState>) : sig<pinState> =
    match incoming {
        signal(just(currentState)) => {
            let {actualState:=actualState,
                lastState:=lastState,
                lastDebounceTime:=lastDebounceTime} = buttonState
            let retState =
                if currentState != lastState {
                    buttonState.lastState = currentState
                    buttonState.lastDebounceTime = Time:now()
                    actualState
                } else if (currentState != actualState) && ((Time:now() - buttonState.lastDebounceTime) > delay) {
                    buttonState.actualState = currentState
                    buttonState.lastState = currentState
                    currentState
                } else {
                    buttonState.lastState = currentState
                    actualState
                }
            signal(just(retState))
        }
        _ =>
            incoming
    }

/*
    Function: debounce

    Debounces the incoming Io:pinState signal by checking twice in 50 ms to make
    sure the pushbutton is definitely pressed.

    Type Signature:
    
        | (inout buttonState, sig<pinState>) -> sig<pinState>

    Parameters:
        buttonState : inout buttonState - Used to keep track of state between
            debounce calls
        incoming : sig<pinState> - The incoming signal

    Returns:
        A signal that will ideally reflect the actual state of the button.

    See Also:
        Io:risingEdge, Io:fallingEdge, Io:edge
*/
fun debounce(inout buttonState, incoming : sig<pinState>) : sig<pinState> =
    debounceDelay(50, inout buttonState, incoming)
